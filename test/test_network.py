# test script for gnn model
# generated by claude
import sys
import os
import unittest
import torch
import numpy as np
import matplotlib.pyplot as plt

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from src.models.gnn import GridCellModule, PlaceCellModule, SpatialNetwork

class TestSpatialNetwork(unittest.TestCase):
    
    def setUp(self):
        # Set random seed for reproducibility
        torch.manual_seed(42)
        np.random.seed(42)
        
        # Create a simple spatial network for testing
        self.input_size = 2  # (x, y)
        self.hidden_size = 64
        self.output_size = 4
        self.num_grid_modules = 4
        self.num_place_cells = 50
        
        self.network = SpatialNetwork(
            input_size=self.input_size,
            hidden_size=self.hidden_size,
            output_size=self.output_size,
            num_grid_modules=self.num_grid_modules,
            num_place_cells=self.num_place_cells
        )
    
    def test_grid_cell_module(self):
        """Test grid cell module outputs have expected shape and values"""
        module = GridCellModule(input_size=2, output_size=16, scale=2.0)
        
        # Test with single input
        pos = torch.tensor([[0.5, 0.5]], dtype=torch.float32)
        output = module(pos)
        
        # Check output shape
        self.assertEqual(output.shape, (1, 3))
        
        # Check output values are in the valid range for tanh activation (-1, 1)
        self.assertTrue(torch.all(output >= -1.0))
        self.assertTrue(torch.all(output <= 1.0))
        
        # Test with batch input
        batch_pos = torch.rand((10, 2), dtype=torch.float32)
        batch_output = module(batch_pos)
        
        # Check batch output shape
        self.assertEqual(batch_output.shape, (10, 3))
    
    def test_place_cell_module(self):
        """Test place cell module outputs have expected shape and values"""
        module = PlaceCellModule(input_size=2, num_place_cells=30)
        
        # Test with single input
        pos = torch.tensor([[0.5, 0.5]], dtype=torch.float32)
        output = module(pos)
        
        # Check output shape
        self.assertEqual(output.shape, (1, 30))
        
        # Check output values are in the valid range for exponential (0, 1)
        self.assertTrue(torch.all(output >= 0.0))
        self.assertTrue(torch.all(output <= 1.0))
        
        # Test with batch input
        batch_pos = torch.rand((10, 2), dtype=torch.float32)
        batch_output = module(batch_pos)
        
        # Check batch output shape
        self.assertEqual(batch_output.shape, (10, 30))
    
    def test_spatial_network(self):
        """Test spatial network produces expected output"""
        # Test with single input
        pos = torch.tensor([[0.5, 0.5]], dtype=torch.float32)
        output = self.network(pos)
        
        # Check output shape
        self.assertEqual(output.shape, (1, self.output_size))
        
        # Test with batch input
        batch_pos = torch.rand((10, 2), dtype=torch.float32)
        batch_output = self.network(batch_pos)
        
        # Check batch output shape
        self.assertEqual(batch_output.shape, (10, self.output_size))
    
    def test_visualization(self):
        """Test visualization of grid and place cell activity"""
        # Create a grid of positions for visualization
        resolution = 30
        x = np.linspace(-1, 1, resolution)
        y = np.linspace(-1, 1, resolution)
        xx, yy = np.meshgrid(x, y)
        positions = np.column_stack((xx.flatten(), yy.flatten()))
        pos_tensor = torch.FloatTensor(positions)
        
        # Select one grid module to visualize
        grid_module = self.network.grid_modules[0]
        grid_activity = grid_module(pos_tensor).detach().numpy()
        
        # Sum across the 3 directional components to get a single value per position
        grid_sum = np.sum(grid_activity, axis=1)
        
        # Reshape to 2D grid for visualization
        grid_pattern = grid_sum.reshape(resolution, resolution)
        
        # Visualize place cell activity
        place_activity = self.network.place_cells(pos_tensor).detach().numpy()
        
        # Sum over all place cells to get a heatmap
        place_sum = np.sum(place_activity, axis=1).reshape(resolution, resolution)
        
        # Basic assertion to check activity patterns exist
        self.assertTrue(np.any(grid_pattern != 0))
        self.assertTrue(np.any(place_sum != 0))
        
        print("Grid and place cell activity tests passed!")
        
    def test_visualize_grid_cell_modules(self):
        """Test visualization of grid cell modules with hexagonal patterns"""
        resolution = 100
        x = np.linspace(-2, 2, resolution)
        y = np.linspace(-2, 2, resolution)
        xx, yy = np.meshgrid(x, y)
        positions = np.column_stack((xx.flatten(), yy.flatten()))
        pos_tensor = torch.FloatTensor(positions)
        
        # Create figure
        fig, axes = plt.subplots(2, 3, figsize=(15, 10))
        axes = axes.flatten()
        
        # Create test grid modules with different scales
        scales = [2.0, 2.8, 3.6, 4.4, 5.2, 6.0]
        test_modules = [GridCellModule(input_size=2, output_size=16, scale=s) for s in scales[:6]]
        
        # Visualize each grid module
        for i, module in enumerate(test_modules):
            if i >= len(axes):
                break
            
            # Get raw grid cell activations
            with torch.no_grad():
                grid_activity = module(pos_tensor).detach().numpy()
            
            # The hexagonal pattern emerges from the sum of these components
            # (represents summation of membrane potentials in biological grid cells)
            grid_sum = np.sum(grid_activity, axis=1)
            
            # Reshape to 2D grid for visualization
            grid_pattern = grid_sum.reshape(resolution, resolution)
            
            # Plot the grid pattern
            im = axes[i].imshow(grid_pattern, cmap='viridis', origin='lower',
                              extent=[-2, 2, -2, 2])
            axes[i].set_title(f'Grid Module {i+1}, Scale={scales[i]:.2f}')
            fig.colorbar(im, ax=axes[i])
        
        # Create output directory if it doesn't exist
        os.makedirs('./logs/plots', exist_ok=True)
        plt.tight_layout()
        plt.savefig('./logs/plots/grid_modules.png')
        plt.close()
        
        self.assertTrue(True)

if __name__ == '__main__':
    unittest.main()